exec("""\nA2=KeyboardInterrupt\nA1=EOFError\nA0=ValueError\ns='inf'\nr='rb'\nq='r'\np=float\no=bin\nn=str\nk='ignore'\nj=input\ne='.jpeg'\nd='B'\nc=False\na='wb'\nZ='utf-8'\nY=True\nX=sum\nW=list\nV=print\nT='.txt'\nS='.jpg'\nR='0'\nP='1'\nO='slow'\nN=''\nM=min\nL=max\nK=open\nI=Exception\nH=int\nG=bytearray\nF=None\nE=bytes\nD=b''\nC=range\nB=len\nimport os as J,sys,math as t,struct as f,array,random as U,heapq as g,binascii as b,logging as A,paq,zlib as h,hashlib as l\nfrom enum import Enum\nfrom typing import List,Dict,Tuple,Optional,Union\nfrom mpmath import mp\nA.basicConfig(level=A.INFO,format='%(asctime)s - %(levelname)s - %(message)s',handlers=[A.StreamHandler()])\nAG='PAQJP_6_Smart'\nA3=1024\nm='pi_digits.txt'\nu=[A for A in C(2,256)if all(A%B!=0 for B in C(2,H(A**.5)+1))]\nAH=1<<15\nv=['eng_news_2005_1M-sentences.txt','eng_news_2005_1M-words.txt','eng_news_2005_1M-sources.txt','eng_news_2005_1M-co_n.txt','eng_news_2005_1M-co_s.txt','eng_news_2005_1M-inv_so.txt','eng_news_2005_1M-meta.txt','Dictionary.txt','the-complete-reference-html-css-fifth-edition.txt','words.txt.paq','lines.txt.paq','sentence.txt.paq']\ndef w(digits,filename=m):\n	D=digits;C=filename\n	try:\n		with K(C,'w')as E:E.write(','.join(n(A)for A in D))\n		A.info(f"Successfully saved {B(D)} base-10 pi digits to {C}");return Y\n	except I as F:A.error(f"Failed to save base-10 pi digits to {C}: {F}");return c\ndef A4(filename=m,expected_count=3):\n	G=expected_count;C=filename\n	try:\n		if not J.path.isfile(C):A.warning(f"Base-10 pi digits file {C} does not exist");return\n		with K(C,q)as M:\n			L=M.read().strip()\n			if not L:A.warning(f"Base-10 pi digits file {C} is empty");return\n			D=[]\n			for E in L.split(','):\n				if not E.isdigit():A.warning(f"Invalid integer in {C}: {E}");return\n				F=H(E)\n				if not 0<=F<=255:A.warning(f"Digit out of range in {C}: {F}");return\n				D.append(F)\n			if B(D)!=G:A.warning(f"Loaded {B(D)} digits, expected {G}");return\n			A.info(f"Successfully loaded {B(D)} base-10 pi digits from {C}");return D\n	except I as N:A.error(f"Failed to load base-10 pi digits from {C}: {N}");return\ndef A5(num_digits=3,filename=m):\n	E=filename;C=num_digits;J=A4(E,C)\n	if J is not F:return J\n	try:\n		mp.dps=C;D=[H(A)for A in mp.pi.digits(10)[0]]\n		if B(D)!=C:A.error(f"Generated {B(D)} digits, expected {C}");raise A0('Incorrect number of pi digits generated')\n		if not all(0<=A<=9 for A in D):A.error('Generated pi digits contain invalid values');raise A0('Invalid pi digits generated')\n		K=[A*255//9%256 for A in D];w(K,E);return K\n	except I as L:A.error(f"Failed to generate base-10 pi digits: {L}");M=[3,1,4];G=[A*255//9%256 for A in M[:C]];A.warning(f"Using {B(G)} fallback base-10 digits");w(G,E);return G\nA6=A5(3)\nclass Q(Enum):DEFAULT=0;JPEG=1;TEXT=3\nclass AI:\n	def __init__(A,s=N):A.data=G(s.encode(Z))\n	def resize(A,new_size):\n		C=new_size\n		if C>B(A.data):A.data+=G(C-B(A.data))\n		else:A.data=A.data[:C]\n	def size(A):return B(A.data)\n	def c_str(A):return A.data.decode(Z,errors=k)\n	def __iadd__(A,s):A.data+=s.encode(Z);return A\n	def __getitem__(A,index):return A.data[index]\n	def __setitem__(A,index,value):A.data[index]=value\n	def __str__(A):return A.data.decode(Z,errors=k)\nclass x:\n	def __init__(A,size=0,initial_value=0):A.data=array.array(d,[initial_value]*size)\n	def resize(A,new_size):\n		C=new_size\n		if C>B(A.data):A.data.extend([0]*(C-B(A.data)))\n		else:A.data=A.data[:C]\n	def size(A):return B(A.data)\n	def __getitem__(A,index):return A.data[index]\n	def __setitem__(A,index,value):A.data[index]=value\n	def __len__(A):return B(A.data)\nclass A7:\n	def __init__(A,size=0):A.size_=size;A.data=x(size);A.pos=0\n	def setsize(B,size):\n		A=size\n		if A>0 and A&A-1==0:B.size_=A;B.data.resize(A)\n	def __getitem__(A,index):return A.data[index&A.size_-1]\n	def __call__(A,i):return A.data[A.pos-i&A.size_-1]\n	def size(A):return A.size_\nAJ=A7()\nclass y:\n	def __init__(A,left=F,right=F,symbol=F):A.left=left;A.right=right;A.symbol=symbol\n	def is_leaf(A):return A.left is F and A.right is F\nclass A8:\n	def __init__(A):A.table=[[1,2,0,0],[3,5,1,0],[4,6,0,1],[7,10,2,0],[8,12,1,1],[9,13,1,1],[11,14,0,2],[15,19,3,0],[16,23,2,1],[17,24,2,1],[18,25,2,1],[20,27,1,2],[21,28,1,2],[22,29,1,2],[26,30,0,3],[31,33,4,0],[32,35,3,1],[32,35,3,1],[32,35,3,1],[32,35,3,1],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[34,37,2,2],[36,39,1,3],[36,39,1,3],[36,39,1,3],[36,39,1,3],[38,40,0,4],[41,43,5,0],[42,45,4,1],[42,45,4,1],[44,47,3,2],[44,47,3,2],[46,49,2,3],[46,49,2,3],[48,51,1,4],[48,51,1,4],[50,52,0,5],[53,43,6,0],[54,57,5,1],[54,57,5,1],[56,59,4,2],[56,59,4,2],[58,61,3,3],[58,61,3,3],[60,63,2,4],[60,63,2,4],[62,65,1,5],[62,65,1,5],[50,66,0,6],[67,55,7,0],[68,57,6,1],[68,57,6,1],[70,73,5,2],[70,73,5,2],[72,75,4,3],[72,75,4,3],[74,77,3,4],[74,77,3,4],[76,79,2,5],[76,79,2,5],[62,81,1,6],[62,81,1,6],[64,82,0,7],[83,69,8,0],[84,76,7,1],[84,76,7,1],[86,73,6,2],[86,73,6,2],[44,59,5,3],[44,59,5,3],[58,61,4,4],[58,61,4,4],[60,49,3,5],[60,49,3,5],[76,89,2,6],[76,89,2,6],[78,91,1,7],[78,91,1,7],[80,92,0,8],[93,69,9,0],[94,87,8,1],[94,87,8,1],[96,45,7,2],[96,45,7,2],[48,99,2,7],[48,99,2,7],[88,101,1,8],[88,101,1,8],[80,102,0,9],[103,69,10,0],[104,87,9,1],[104,87,9,1],[106,57,8,2],[106,57,8,2],[62,109,2,8],[62,109,2,8],[88,111,1,9],[88,111,1,9],[80,112,0,10],[113,85,11,0],[114,87,10,1],[114,87,10,1],[116,57,9,2],[116,57,9,2],[62,119,2,9],[62,119,2,9],[88,121,1,10],[88,121,1,10],[90,122,0,11],[123,85,12,0],[124,97,11,1],[124,97,11,1],[126,57,10,2],[126,57,10,2],[62,129,2,10],[62,129,2,10],[98,131,1,11],[98,131,1,11],[90,132,0,12],[133,85,13,0],[134,97,12,1],[134,97,12,1],[136,57,11,2],[136,57,11,2],[62,139,2,11],[62,139,2,11],[98,141,1,12],[98,141,1,12],[90,142,0,13],[143,95,14,0],[144,97,13,1],[144,97,13,1],[68,57,12,2],[68,57,12,2],[62,81,2,12],[62,81,2,12],[98,147,1,13],[98,147,1,13],[100,148,0,14],[149,95,15,0],[150,107,14,1],[150,107,14,1],[108,151,1,14],[108,151,1,14],[100,152,0,15],[153,95,16,0],[154,107,15,1],[108,155,1,15],[100,156,0,16],[157,95,17,0],[158,107,16,1],[108,159,1,16],[100,160,0,17],[161,105,18,0],[162,107,17,1],[108,163,1,17],[110,164,0,18],[165,105,19,0],[166,117,18,1],[118,167,1,18],[110,168,0,19],[169,105,20,0],[170,117,19,1],[118,171,1,19],[110,172,0,20],[173,105,21,0],[174,117,20,1],[118,175,1,20],[110,176,0,21],[177,105,22,0],[178,117,21,1],[118,179,1,21],[120,184,0,23],[185,115,24,0],[186,127,23,1],[128,187,1,23],[120,188,0,24],[189,115,25,0],[190,127,24,1],[128,191,1,24],[120,192,0,25],[193,115,26,0],[194,127,25,1],[128,195,1,25],[120,196,0,26],[197,115,27,0],[198,127,26,1],[128,199,1,26],[120,200,0,27],[201,115,28,0],[202,127,27,1],[128,203,1,27],[120,204,0,28],[205,115,29,0],[206,127,28,1],[128,207,1,28],[120,208,0,29],[209,125,30,0],[210,127,29,1],[128,211,1,29],[130,212,0,30],[213,125,31,0],[214,137,30,1],[138,215,1,30],[130,216,0,31],[217,125,32,0],[218,137,31,1],[138,219,1,31],[130,220,0,32],[221,125,33,0],[222,137,32,1],[138,223,1,32],[130,224,0,33],[225,125,34,0],[226,137,33,1],[138,227,1,33],[130,228,0,34],[229,125,35,0],[230,137,34,1],[138,231,1,34],[130,232,0,35],[233,125,36,0],[234,137,35,1],[138,235,1,35],[130,236,0,36],[237,125,37,0],[238,137,36,1],[138,239,1,36],[130,240,0,37],[241,125,38,0],[242,137,37,1],[138,243,1,37],[130,244,0,38],[245,135,39,0],[246,137,38,1],[138,247,1,38],[140,248,0,39],[249,135,40,0],[250,69,39,1],[80,251,1,39],[140,252,0,40],[249,135,41,0],[250,69,40,1],[80,251,1,40],[140,252,0,41]]\n	def nex(A,state,sel):return A.table[state][sel]\nAK=A8()\ndef A9(data,repeat=100):\n	A=G(data)\n	for D in u:\n		F=D if D==2 else L(1,t.ceil(D*4096/28672))\n		for I in C(repeat):\n			for H in C(0,B(A),3):A[H]^=F\n	return E(A)\ndef AA(data,chunk_size=4):\n	A=chunk_size;D=G()\n	for F in C(0,B(data),A):H=data[F:F+A];D.extend([A^255 for A in H])\n	return E(D)\ndef z(n):\n	if n<2:return c\n	if n==2:return Y\n	if n%2==0:return c\n	for A in C(3,H(n**.5)+1,2):\n		if n%A==0:return c\n	return Y\ndef i(n):\n	A=0\n	while Y:\n		if z(n-A):return n-A\n		if z(n+A):return n+A\n		A+=1\ndef quit(message=F):\n	A=message\n	if A:V(A)\n	sys.exit(1)\ndef AL(x):\n	if x<0:return 0\n	A=0\n	while x>0:x>>=1;A+=1\n	return A\ndef AB(d,n=12,repeat=1000):\n	B=(1<<n)-1;A=d\n	for E in C(repeat):\n		if A>2047:A=B\n		if A<-2047:A=0\n		D=(1<<n)/(1+t.exp(-A/512.));A=H(D);A=M(L(A,0),B)\n	return A\ndef AM(p):\n	A=x(4096);B=0\n	for D in C(-2047,2048):\n		E=AB(D)\n		for F in C(B,E+1):A[F]=D\n		B=E+1\n	A[4095]=2047;return A[p]\ndef hash(*A):C=A[0]*200002979+A[1]*30005491+(A[2]if B(A)>2 else 4294967295)*50004239+(A[3]if B(A)>3 else 4294967295)*70004807+(A[4]if B(A)>4 else 4294967295)*110002499;return C^C>>9^A[0]>>2^A[1]>>3^(A[2]if B(A)>2 else 0)>>4^(A[3]if B(A)>3 else 0)>>5^(A[4]if B(A)>4 else 0)>>6\nclass AC:\n	def __init__(A):A.PI_DIGITS=A6;A.PRIMES=u;A.seed_tables=A.generate_seed_tables();A.SQUARE_OF_ROOT=2;A.ADD_NUMBERS=1;A.MULTIPLY=3;A.dictionaries=A.load_dictionaries()\n	def load_dictionaries(F):\n		C=[]\n		for B in v:\n			if J.path.exists(B):\n				try:\n					with K(B,q,encoding=Z,errors=k)as D:C.append(D.read())\n					A.info(f"Loaded dictionary file: {B}")\n				except I as E:A.warning(f"Could not read {B}: {E}")\n			else:A.warning(f"Missing dictionary file: {B}")\n		return C\n	def compute_sha256(A,data):return l.sha256(data).hexdigest()\n	def compute_sha256_binary(A,data):return l.sha256(data).digest()\n	def find_hash_in_dictionaries(G,hash_hex):\n		C=hash_hex\n		for B in v:\n			if not J.path.exists(B):continue\n			try:\n				with K(B,q,encoding=Z,errors=k)as D:\n					for E in D:\n						if C in E:A.info(f"Hash {C[:16]}... found in {B}");return B\n			except I as F:A.warning(f"Error searching {B}: {F}")\n	def generate_8byte_sha(D,data):\n		try:B=l.sha256(data).digest();return B[:8]\n		except I as C:A.error(f"Failed to generate SHA: {C}");return\n	def generate_seed_tables(D,num_tables=126,table_size=256,min_val=5,max_val=255,seed=42):\n		U.seed(seed);A=[]\n		for E in C(num_tables):B=[U.randint(min_val,max_val)for A in C(table_size)];A.append(B)\n		return A\n	def get_seed(A,table_idx,value):\n		C=table_idx\n		if 0<=C<B(A.seed_tables):return A.seed_tables[C][value%B(A.seed_tables[C])]\n		return 0\n	def binary_to_file(O,binary_data,filename):\n		F=filename;E=binary_data\n		try:\n			if not E:\n				A.warning(f"Empty binary data, writing empty file to {F}")\n				with K(F,a)as G:G.write(D)\n				return Y\n			J=H(E,2);L=(B(E)+7)//8;C='%0*x'%(L*2,J)\n			if B(C)%2!=0:C=R+C\n			M=b.unhexlify(C)\n			with K(F,a)as G:G.write(M)\n			return Y\n		except I as N:A.error(f"Error saving file: {n(N)}");return c\n	def file_to_binary(J,filename):\n		D=filename\n		try:\n			with K(D,r)as E:\n				C=E.read()\n				if not C:A.warning(f"Empty file {D}, returning empty binary string");return N\n				F=o(H(b.hexlify(C),16))[2:].zfill(B(C)*8);return F\n		except I as G:A.error(f"Error reading file: {n(G)}");return\n	def calculate_frequencies(E,binary_str):\n		C=binary_str\n		if not C:A.warning('Empty binary string, returning empty frequencies');return{}\n		B={}\n		for D in C:B[D]=B.get(D,0)+1\n		return B\n	def build_huffman_tree(J,frequencies):\n		D=frequencies\n		if not D:A.warning('No frequencies provided, returning None for Huffman tree');return\n		C=[(B,y(symbol=A))for(A,B)in D.items()];g.heapify(C)\n		while B(C)>1:E,F=g.heappop(C);G,H=g.heappop(C);I=y(left=F,right=H);g.heappush(C,(E+G,I))\n		return C[0][1]\n	def generate_huffman_codes(E,root,current_code=N,codes={}):\n		D=current_code;C=codes;B=root\n		if B is F:A.warning('Huffman tree is None, returning empty codes');return{}\n		if B.is_leaf():C[B.symbol]=D or R;return C\n		if B.left:E.generate_huffman_codes(B.left,D+R,C)\n		if B.right:E.generate_huffman_codes(B.right,D+P,C)\n		return C\n	def compress_data_huffman(C,binary_str):\n		D=binary_str\n		if not D:A.warning('Empty binary string, returning empty compressed string');return N\n		G=C.calculate_frequencies(D);E=C.build_huffman_tree(G)\n		if E is F:return N\n		B=C.generate_huffman_codes(E)\n		if R not in B:B[R]=R\n		if P not in B:B[P]=P\n		H=N.join(B[A]for A in D);return H\n	def decompress_data_huffman(C,compressed_str):\n		D=compressed_str\n		if not D:A.warning('Empty compressed string, returning empty decompressed string');return N\n		I=C.calculate_frequencies(D);E=C.build_huffman_tree(I)\n		if E is F:return N\n		J=C.generate_huffman_codes(E);G={B:A for(A,B)in J.items()};H=N;B=N\n		for K in D:\n			B+=K\n			if B in G:H+=G[B];B=N\n		return H\n	def paq_compress(E,data):\n		if not data:A.warning('paq_compress: Empty input data, returning empty bytes');return D\n		try:B=paq.compress(data);A.info('PAQ9a compression complete.');return B\n		except I as C:A.error(f"PAQ9a compression failed: {C}");return\n	def paq_decompress(E,data):\n		if not data:A.warning('paq_decompress: Empty input data, returning empty bytes');return D\n		try:B=paq.decompress(data);A.info('PAQ9a decompression complete.');return B\n		except I as C:A.error(f"PAQ9a decompression failed: {C}");return\n	def compress_data_zlib(E,data_bytes):\n		B=data_bytes\n		if not B:A.warning('Empty data bytes, returning empty compressed data');return D\n		try:return h.compress(B)\n		except h.error as C:A.error(f"zlib compression error: {C}");return\n	def decompress_data_zlib(E,compressed_data):\n		B=compressed_data\n		if not B:A.warning('Empty compressed data, returning empty decompressed data');return D\n		try:return h.decompress(B)\n		except h.error as C:A.error(f"zlib decompression error: {C}");return\n	def reversible_transform(C,data):A.info('Applying XOR transform (0xAA)...');B=E(A^170 for A in data);A.info('XOR transform complete.');return B\n	def reverse_reversible_transform(B,data):A.info('Reversing XOR transform (0xAA)...');C=B.reversible_transform(data);A.info('XOR transform reversed.');return C\n	def transform_01(B,data,repeat=100):\n		if not data:A.warning('transform_01: Empty input data, returning empty bytes');return D\n		return A9(data,repeat=repeat)\n	def reverse_transform_01(B,data,repeat=100):\n		if not data:A.warning('reverse_transform_01: Empty input data, returning empty bytes');return D\n		return B.transform_01(data,repeat=repeat)\n	def transform_03(B,data):\n		if not data:A.warning('transform_03: Empty input data, returning empty bytes');return D\n		return AA(data)\n	def reverse_transform_03(B,data):\n		if not data:A.warning('reverse_transform_03: Empty input data, returning empty bytes');return D\n		return B.transform_03(data)\n	def transform_04(I,data,repeat=100):\n		if not data:A.warning('transform_04: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for J in C(repeat):\n			for H in C(B(F)):F[H]=(F[H]-H%256)%256\n		return E(F)\n	def reverse_transform_04(I,data,repeat=100):\n		if not data:A.warning('reverse_transform_04: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for J in C(repeat):\n			for H in C(B(F)):F[H]=(F[H]+H%256)%256\n		return E(F)\n	def transform_05(J,data,shift=3):\n		I=shift\n		if not data:A.warning('transform_05: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for H in C(B(F)):F[H]=(F[H]<<I|F[H]>>8-I)&255\n		return E(F)\n	def reverse_transform_05(J,data,shift=3):\n		I=shift\n		if not data:A.warning('reverse_transform_05: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for H in C(B(F)):F[H]=(F[H]>>I|F[H]<<8-I)&255\n		return E(F)\n	def transform_06(J,data,seed=42):\n		if not data:A.warning('transform_06: Empty input data, returning empty bytes');return D\n		U.seed(seed);H=W(C(256));U.shuffle(H);F=G(data)\n		for I in C(B(F)):F[I]=H[F[I]]\n		return E(F)\n	def reverse_transform_06(L,data,seed=42):\n		if not data:A.warning('reverse_transform_06: Empty input data, returning empty bytes');return D\n		U.seed(seed);I=W(C(256));U.shuffle(I);J=[0]*256\n		for(F,K)in enumerate(I):J[K]=F\n		H=G(data)\n		for F in C(B(H)):H[F]=J[H[F]]\n		return E(H)\n	def transform_07(I,data,repeat=100):\n		F=data\n		if not F:A.warning('transform_07: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,L(1,H(Q)));A.info(f"transform_07: Using {O} cycles for {B(F)} bytes");P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[P:]+I.PI_DIGITS[:P];R=B(F)%256\n		for K in C(B(J)):J[K]^=R\n		for T in C(O*repeat//10):\n			for K in C(B(J)):S=I.PI_DIGITS[K%N];J[K]^=S\n		return E(J)\n	def reverse_transform_07(I,data,repeat=100):\n		F=data\n		if not F:A.warning('reverse_transform_07: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,L(1,H(Q)));A.info(f"reverse_transform_07: Using {O} cycles for {B(F)} bytes")\n		for T in C(O*repeat//10):\n			for K in C(B(J)):R=I.PI_DIGITS[K%N];J[K]^=R\n		S=B(F)%256\n		for K in C(B(J)):J[K]^=S\n		P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[-P:]+I.PI_DIGITS[:-P];return E(J)\n	def transform_08(I,data,repeat=100):\n		F=data\n		if not F:A.warning('transform_08: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,L(1,H(Q)));A.info(f"transform_08: Using {O} cycles for {B(F)} bytes");P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[P:]+I.PI_DIGITS[:P];R=i(B(F)%256)\n		for K in C(B(J)):J[K]^=R\n		for T in C(O*repeat//10):\n			for K in C(B(J)):S=I.PI_DIGITS[K%N];J[K]^=S\n		return E(J)\n	def reverse_transform_08(I,data,repeat=100):\n		F=data\n		if not F:A.warning('reverse_transform_08: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,L(1,H(Q)));A.info(f"reverse_transform_08: Using {O} cycles for {B(F)} bytes")\n		for T in C(O*repeat//10):\n			for K in C(B(J)):R=I.PI_DIGITS[K%N];J[K]^=R\n		S=i(B(F)%256)\n		for K in C(B(J)):J[K]^=S\n		P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[-P:]+I.PI_DIGITS[:-P];return E(J)\n	def transform_09(I,data,repeat=100):\n		N=repeat;F=data\n		if not F:A.warning('transform_09: Empty input data, returning empty bytes');return D\n		J=G(F);O=B(I.PI_DIGITS);R=B(F)/1024;P=M(10,L(1,H(R)));A.info(f"transform_09: Using {P} cycles with {N} repeats for {B(F)} bytes");Q=B(F)%O;I.PI_DIGITS=I.PI_DIGITS[Q:]+I.PI_DIGITS[:Q];S=i(B(F)%256);T=B(F)%B(I.seed_tables);U=I.get_seed(T,B(F))\n		for K in C(B(J)):J[K]^=S^U\n		for W in C(P*N//10):\n			for K in C(B(J)):V=I.PI_DIGITS[K%O];J[K]^=V^K%256\n		return E(J)\n	def reverse_transform_09(I,data,repeat=100):\n		N=repeat;F=data\n		if not F:A.warning('reverse_transform_09: Empty input data, returning empty bytes');return D\n		J=G(F);O=B(I.PI_DIGITS);R=B(F)/1024;P=M(10,L(1,H(R)));A.info(f"reverse_transform_09: Using {P} cycles with {N} repeats for {B(F)} bytes")\n		for W in C(P*N//10):\n			for K in C(B(J)):S=I.PI_DIGITS[K%O];J[K]^=S^K%256\n		T=i(B(F)%256);U=B(F)%B(I.seed_tables);V=I.get_seed(U,B(F))\n		for K in C(B(J)):J[K]^=T^V\n		Q=B(F)%O;I.PI_DIGITS=I.PI_DIGITS[-Q:]+I.PI_DIGITS[:-Q];return E(J)\n	def transform_10(J,data,repeat=100):\n		O=repeat;D=data\n		if not D:A.warning('transform_10: Empty input data, returning empty bytes with n=0');return E([0])\n		K=G(D);Q=B(D)/1024;P=M(10,L(1,H(Q)));A.info(f"transform_10: Using {P} cycles with {O} repeats for {B(D)} bytes");N=0\n		for I in C(B(D)-1):\n			if D[I]==88 and D[I+1]==49:N+=1\n		A.info(f"transform_10: Found {N} 'X1' sequences");F=(N*J.SQUARE_OF_ROOT+J.ADD_NUMBERS)//3*J.MULTIPLY;F=F%256;A.info(f"transform_10: Computed n = {F}")\n		for R in C(P*O//10):\n			for I in C(B(K)):K[I]^=F\n		return E([F])+E(K)\n	def reverse_transform_10(Q,data,repeat=100):\n		J=repeat;F=data\n		if B(F)<1:A.warning('reverse_transform_10: Data too short, returning empty bytes');return D\n		K=F[0];I=G(F[1:]);O=B(F)/1024;N=M(10,L(1,H(O)));A.info(f"reverse_transform_10: Using {N} cycles with {J} repeats for {B(F)} bytes, n = {K}")\n		for R in C(N*J//10):\n			for P in C(B(I)):I[P]^=K\n		return E(I)\n	def transform_11(Q,data,repeat=100):\n		N=repeat;D=data\n		if not D:A.warning('transform_11: Empty input data, returning y=0 with no data');return f.pack(d,0)\n		O=C(1,256);K=F;L=F;M=p(s);R=X(1 for A in D if A==0);A.info(f"transform_11: Testing {B(O)} y values for {B(D)} bytes with {N} repeats, {R} zero bytes")\n		for E in O:\n			H=G(D)\n			for T in C(N):\n				for P in C(B(H)):H[P]=(H[P]+E+1)%256\n			try:\n				J=Q.paq_compress(H)\n				if J is F:A.warning(f"transform_11: Compression with y={E} returned None");continue\n				if B(J)<M:K=J;L=E;M=B(J)\n			except I as S:A.warning(f"transform_11: Compression with y={E} failed: {S}");continue\n		if K is F:A.error('transform_11: All compression attempts failed, returning original data with y=0');return f.pack(d,0)+D\n		A.info(f"transform_11: Selected y={L} with compressed size {M}");return f.pack(d,L)+K\n	def reverse_transform_11(O,data,repeat=100):\n		J=repeat;H=data\n		if B(H)<1:A.warning('reverse_transform_11: Data too short to contain y, returning empty bytes');return D\n		K=f.unpack(d,H[:1])[0];L=H[1:]\n		if not L:A.warning('reverse_transform_11: No compressed data after y, returning empty bytes');return D\n		try:\n			M=O.paq_decompress(L)\n			if not M:A.warning('reverse_transform_11: Decompression returned empty data');return D\n		except I as P:A.error(f"reverse_transform_11: Decompression failed: {P}");return D\n		F=G(M);Q=X(1 for A in F if A==0);A.info(f"reverse_transform_11: Processing {B(F)} bytes with y={K}, {Q} zero bytes, {J} repeats")\n		for S in C(J):\n			for N in C(B(F)):F[N]=(F[N]-K-1)%256\n		R=X(1 for A in F if A==0);A.info(f"reverse_transform_11: Restored data, {R} zero bytes after transformation");return E(F)\n	def generate_transform_method(J,marker):\n		F=marker\n		def H(data,repeat=1000):\n			K=repeat;H=data\n			if not H:A.warning(f"transform_{F}: Empty input data, returning empty bytes");return D\n			I=G(H);J=B(H);P=L(2000,M(256000,J));N=J%P%256;A.info(f"transform_{F}: Using size_mod={N} for {J} bytes, repeat={K}")\n			for Q in C(K):\n				for O in C(B(I)):I[O]^=(N+O%256)%256\n			return E(I)\n		def I(data,repeat=1000):\n			K=repeat;H=data\n			if not H:A.warning(f"reverse_transform_{F}: Empty input data, returning empty bytes");return D\n			I=G(H);J=B(H);P=L(2000,M(256000,J));N=J%P%256;A.info(f"reverse_transform_{F}: Using size_mod={N} for {J} bytes, repeat={K}")\n			for Q in C(K):\n				for O in C(B(I)):I[O]^=(N+O%256)%256\n			return E(I)\n		return H,I\n	def compress(D,input_data,input_file):\n		I=input_file;C=input_data\n		if not C:A.warning('Empty input data, returning minimal output');return E([0])\n		J=D.compute_sha256(C);A.info(f"SHA-256 of input: {J[:16]}...");K=D.find_hash_in_dictionaries(J)\n		if K:A.info(f"Hash found in dictionary: {K}")\n		else:A.info('Hash not found in any dictionary. Proceeding with lossless compression.')\n		if I.endswith('.paq')and any(A in I for A in['words','lines','sentence']):\n			H=D.generate_8byte_sha(C)\n			if H and B(C)>8:A.info(f"SHA-8 for .paq file: {H.hex()}");return H\n			A.info('Original file smaller than SHA hash, skipping compression.');return\n		L=D.reversible_transform(C);G=D.paq_compress(L)\n		if G is F:A.error('Compression failed.');return\n		if B(G)<B(C):M=D.compute_sha256_binary(C)+G;A.info(f"Smart compression successful. Original size: {B(C)} bytes, Compressed size: {B(G)} bytes");return M\n		else:A.info('Compression not efficient. Returning None.');return\n	def decompress(C,input_data):\n		D=input_data\n		if B(D)<32:A.error('Input data too short for Smart Compressor.');return\n		H=D[:32];I=D[32:];E=C.paq_decompress(I)\n		if E is F:return\n		G=C.reverse_reversible_transform(E);J=C.compute_sha256_binary(G)\n		if J==H:A.info('Hash verification successful.');return G\n		else:A.error('Hash verification failed! Data may be corrupted.');return\n	def compress_with_best_method(G,data,filetype,input_filename,mode=O):\n		V=filetype;P=mode;J=data\n		if not J:A.warning('compress_with_best_method: Empty input data, returning minimal marker');return E([0])\n		X=[(1,G.transform_04),(2,G.transform_01),(3,G.transform_03),(5,G.transform_05),(6,G.transform_06),(7,G.transform_07),(8,G.transform_08),(9,G.transform_09)];d=X+[(10,G.transform_10),(11,G.transform_11)]+[(A,G.generate_transform_method(A)[0])for A in C(12,256)];R=d if P==O else X\n		if V in[Q.JPEG,Q.TEXT]:\n			Y=[(7,G.transform_07),(8,G.transform_08),(9,G.transform_09)]\n			if P==O:Y+=[(10,G.transform_10),(11,G.transform_11)]+[(A,G.generate_transform_method(A)[0])for A in C(12,256)]\n			R=Y+[A for A in R if A[0]not in[7,8,9,10,11]+W(C(12,256))]\n		e=[('paq',G.paq_compress),('zlib',G.compress_data_zlib)];K=F;L=p(s);M=F;S=F\n		for(Z,f)in R:\n			g=f(J)\n			for(a,h)in e:\n				try:\n					T=h(g)\n					if T is F:continue\n					c=B(T)\n					if c<L:L=c;K=T;M=Z;S=a\n				except I as i:A.warning(f"Compression method {a} with transform {Z} failed: {i}");continue\n		if B(J)<A3:\n			j=o(H(b.hexlify(J),16))[2:].zfill(B(J)*8);U=G.compress_data_huffman(j);N=H(U,2).to_bytes((B(U)+7)//8,'big')if U else D\n			if N and B(N)<L:L=B(N);K=N;M=4;S='huffman'\n		if K is F:A.error('All compression methods failed, returning original data with marker 0');return E([0])+J\n		A.info(f"Best compression method: {S}, Marker: {M} for {V.name} in {P} mode");return E([M])+K\n	def decompress_with_best_method(E,data):\n		O=data\n		if B(O)<1:A.warning('decompress_with_best_method: Insufficient data, returning empty bytes');return D,F\n		G=O[0];L=O[1:];M={1:E.reverse_transform_04,2:E.reverse_transform_01,3:E.reverse_transform_03,5:E.reverse_transform_05,6:E.reverse_transform_06,7:E.reverse_transform_07,8:E.reverse_transform_08,9:E.reverse_transform_09,10:E.reverse_transform_10,11:E.reverse_transform_11};M.update({A:E.generate_transform_method(A)[1]for A in C(12,256)})\n		if G==4:\n			T=o(H(b.hexlify(L),16))[2:].zfill(B(L)*8);P=E.decompress_data_huffman(T)\n			if not P:A.warning('Huffman decompression returned empty string');return D,F\n			try:\n				U=(B(P)+7)//8;N='%0*x'%(U*2,H(P,2))\n				if B(N)%2!=0:N=R+N\n				return b.unhexlify(N),F\n			except I as Q:A.error(f"Error converting decompressed Huffman data: {Q}");return D,F\n		if G not in M:A.error(f"Unknown compression method marker: {G}");return D,F\n		try:\n			J=E.paq_decompress(L)\n			if not J:A.warning('PAQ decompression returned empty data');return D,F\n			K=M[G](J);S=X(1 for A in K if A==0);A.info(f"Decompressed with marker {G}, {S} zero bytes in result");return K,G\n		except I as Q:\n			A.warning(f"PAQ decompression failed: {Q}. Trying zlib...");J=E.decompress_data_zlib(L)\n			if J is F:A.error('All decompression methods failed');return D,F\n			K=M[G](J);S=X(1 for A in K if A==0);A.info(f"Decompressed with marker {G} using zlib, {S} zero bytes in result");return K,G\n	def compress_with_zlib_method(D,data,filetype,input_filename,mode=O):\n		N=filetype;H=mode;G=data\n		if not G:A.warning('compress_with_zlib_method: Empty input data, returning minimal marker');return E([0])\n		P=[(1,D.transform_04),(2,D.transform_01),(3,D.transform_03),(5,D.transform_05),(6,D.transform_06),(7,D.transform_07),(8,D.transform_08),(9,D.transform_09)];V=P+[(10,D.transform_10),(11,D.transform_11)]+[(A,D.generate_transform_method(A)[0])for A in C(12,256)];J=V if H==O else P\n		if N in[Q.JPEG,Q.TEXT]:\n			R=[(7,D.transform_07),(8,D.transform_08),(9,D.transform_09)]\n			if H==O:R+=[(10,D.transform_10),(11,D.transform_11)]+[(A,D.generate_transform_method(A)[0])for A in C(12,256)]\n			J=R+[A for A in J if A[0]not in[7,8,9,10,11]+W(C(12,256))]\n		K=F;S=p(s);L=F\n		for(T,X)in J:\n			Y=X(G)\n			try:\n				M=D.compress_data_zlib(Y)\n				if M is F:continue\n				U=B(M)\n				if U<S:S=U;K=M;L=T\n			except I as Z:A.warning(f"zlib compression with transform {T} failed: {Z}");continue\n		if K is F:A.error('All zlib compression methods failed, returning original data with marker 0');return E([0])+G\n		A.info(f"Best zlib compression with Marker: {L} for {N.name} in {H} mode");return E([L])+K\nclass AD:\n	def __init__(A):A.smart_compressor=AC()\n	def compress(G,input_file,output_file,mode=O):\n		H=output_file;C=input_file\n		if not J.path.exists(C):A.error(f"Input file {C} not found.");return\n		if not J.access(C,J.R_OK):A.error(f"No read permission for {C}.");return\n		if J.path.getsize(C)==0:\n			A.warning(f"Input file '{C}' is empty, writing empty output")\n			with K(H,a)as I:I.write(E([0]))\n			return\n		with K(C,r)as V:F=V.read()\n		P=G.smart_compressor.compress(F,C);W=E([0])+P if P else D;Q=AE(C);R=G.smart_compressor.compress_with_best_method(F,Q,C,mode=mode);X=E([1])+R if R else D;S=G.smart_compressor.compress_data_zlib(F);Y=E([2])+S if S else D;T=G.smart_compressor.compress_with_zlib_method(F,Q,C,mode=mode);Z=E([3])+T if T else D;b=[(W,'Smart Compressor'),(X,'PAQJP_6'),(Y,'zlib no transform'),(Z,'zlib with transform')];U=[(A,B)for(A,B)in b if A]\n		if not U:A.error('All compression methods failed.');return\n		L,c=M(U,key=lambda x:B(x[0]));A.info(f"Selected {c} with size {B(L)} bytes")\n		with K(H,a)as I:I.write(L)\n		N=B(F);O=B(L);d=O/N*100 if N>0 else 0;A.info(f"Compression successful. Output saved to {H}. Size: {O} bytes");A.info(f"Original: {N} bytes, Compressed: {O} bytes, Ratio: {d:.2f}%")\n	def decompress(M,input_file,output_file):\n		G=output_file;E=input_file\n		if not J.path.exists(E):A.error(f"Input file {E} not found.");return\n		if not J.access(E,J.R_OK):A.error(f"No read permission for {E}.");return\n		if J.path.getsize(E)==0:\n			A.warning(f"Input file '{E}' is empty, writing empty output")\n			with K(G,a)as P:P.write(D)\n			return\n		with K(E,r)as R:N=R.read()\n		if B(N)<1:A.error('Input data too short to contain marker.');return\n		I=N[0];O=N[1:]\n		if I==0:A.info('Detected Smart Compressor (marker 00)');H=M.smart_compressor.decompress(O)\n		elif I==1:\n			A.info('Detected PAQJP_6 Compressor (marker 01)');H,Q=M.smart_compressor.decompress_with_best_method(O)\n			if H and Q in[7,8,9,10,11]+W(C(12,256)):\n				L=J.path.splitext(E)[1].lower()\n				if not G.endswith((S,e,T)):\n					if L in[S,e]:G+=S\n					elif L==T:G+=T\n		elif I==2:A.info('Detected zlib no transform (marker 02)');H=M.smart_compressor.decompress_data_zlib(O)\n		elif I==3:\n			A.info('Detected zlib with transform (marker 03)');H,Q=M.smart_compressor.decompress_with_best_method(O)\n			if H and Q in[7,8,9,10,11]+W(C(12,256)):\n				L=J.path.splitext(E)[1].lower()\n				if not G.endswith((S,e,T)):\n					if L in[S,e]:G+=S\n					elif L==T:G+=T\n		else:A.error(f"Unknown compression marker: {I:02x}");return\n		if H is F:A.error('Decompression failed.');return\n		with K(G,a)as P:P.write(H)\n		U=B(N);V=B(H);Y=X(1 for A in H if A==0);A.info(f"Decompression successful. Output saved to {G}, {Y} zero bytes in output");A.info(f"Compressed: {U} bytes, Decompressed: {V} bytes")\ndef AE(filename):\n	B,A=J.path.splitext(filename.lower())\n	if A in[S,e]:return Q.JPEG\n	elif A==T:return Q.TEXT\n	else:return Q.DEFAULT\ndef AF():\n	D='2';V('PAQJP_6_Smart Compression System with Dictionary and Base-10 Pi Transformation');V('Created by Jurijus Pacalovas');V('Options:');V('1 - Compress file (Best of Smart Compressor [00], PAQJP_6 [01], zlib no transform [02], or zlib with transform [03])');V('2 - Decompress file');E=AD()\n	try:\n		C=j('Enter 1 or 2: ').strip()\n		if C not in(P,D):A.error('Invalid choice. Exiting.');return\n	except(A1,A2):A.info('Program terminated by user.');return\n	B=O\n	if C==P:\n		try:\n			F=j('Enter compression mode (1 for fast, 2 for slow): ').strip()\n			if F==P:B='fast'\n			elif F==D:B=O\n			else:A.warning('Invalid mode choice. Defaulting to slow mode.');B=O\n		except(A1,A2):A.info('No mode input detected. Defaulting to slow mode.');B=O\n		A.info(f"Selected compression mode: {B}")\n	G=j('Input file name: ').strip();H=j('Output file name: ').strip()\n	if C==P:E.compress(G,H,mode=B)\n	elif C==D:E.decompress(G,H)\nif __name__=='__main__':AF()\n""")

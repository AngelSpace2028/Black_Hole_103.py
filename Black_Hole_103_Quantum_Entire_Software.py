exec("""\nw='inf'\nv='paq_decompress: Empty input data, returning empty bytes'\nu='paq_compress: Empty input data, returning empty bytes'\nt='ignore'\ns='utf-8'\nr=KeyboardInterrupt\nq=EOFError\np=float\nn=ValueError\ni='r'\nh=list\nd='wb'\nc='B'\nb=False\na=True\nZ=input\nU=print\nT=sum\nR='0'\nP='slow'\nO='1'\nN=''\nM=min\nL=open\nK=max\nI=Exception\nH=int\nG=bytearray\nF=None\nE=bytes\nD=b''\nC=range\nB=len\nimport os as J,sys,math,struct as V,array,random as Q,heapq as W,binascii as e,logging as A,paq as X,hashlib as f\nfrom enum import Enum\nfrom typing import List,Dict,Tuple,Optional\nA.basicConfig(level=A.INFO,format='%(asctime)s - %(levelname)s - %(message)s',handlers=[A.StreamHandler()])\nA8='PAQJP_6_Smart'\nx=1024\ng='pi_digits.txt'\nj=[A for A in C(2,256)if all(A%B!=0 for B in C(2,H(A**.5)+1))]\nA9=1<<15\nk=['words_enwik8.txt','eng_news_2005_1M-sentences.txt','eng_news_2005_1M-words.txt','eng_news_2005_1M-sources.txt','eng_news_2005_1M-co_n.txt','eng_news_2005_1M-co_s.txt','eng_news_2005_1M-inv_so.txt','eng_news_2005_1M-meta.txt','Dictionary.txt','the-complete-reference-html-css-fifth-edition.txt','words.txt.paq','lines.txt.paq','sentence.txt.paq']\ndef l(digits,filename=g):\n	D=digits;C=filename\n	try:\n		with L(C,'w')as E:E.write(','.join(str(A)for A in D))\n		A.info(f"Successfully saved {B(D)} base-10 pi digits to {C}");return a\n	except I as F:A.error(f"Failed to save base-10 pi digits to {C}: {F}");return b\ndef y(filename=g,expected_count=3):\n	G=expected_count;C=filename\n	try:\n		if not J.path.isfile(C):A.warning(f"Base-10 pi digits file {C} does not exist");return\n		with L(C,i)as M:\n			K=M.read().strip()\n			if not K:A.warning(f"Base-10 pi digits file {C} is empty");return\n			D=[]\n			for E in K.split(','):\n				if not E.isdigit():A.warning(f"Invalid integer in {C}: {E}");return\n				F=H(E)\n				if not 0<=F<=255:A.warning(f"Digit out of range in {C}: {F}");return\n				D.append(F)\n			if B(D)!=G:A.warning(f"Loaded {B(D)} digits, expected {G}");return\n			A.info(f"Successfully loaded {B(D)} base-10 pi digits from {C}");return D\n	except I as N:A.error(f"Failed to load base-10 pi digits from {C}: {N}");return\ndef z(num_digits=3,filename=g):\n	E=filename;C=num_digits;J=y(E,C)\n	if J is not F:return J\n	try:\n		from mpmath import mp;mp.dps=C;D=[H(A)for A in mp.pi.digits(10)[0]]\n		if B(D)!=C:A.error(f"Generated {B(D)} digits, expected {C}");raise n('Incorrect number of pi digits generated')\n		if not all(0<=A<=9 for A in D):A.error('Generated pi digits contain invalid values');raise n('Invalid pi digits generated')\n		K=[A*255//9%256 for A in D];l(K,E);return K\n	except I as L:A.error(f"Failed to generate base-10 pi digits: {L}");M=[3,1,4];G=[A*255//9%256 for A in M[:C]];A.warning(f"Using {B(G)} fallback base-10 digits");l(G,E);return G\nA0=z(3)\nclass S(Enum):DEFAULT=0;JPEG=1;TEXT=3\nclass m:\n	def __init__(A,left=F,right=F,symbol=F):A.left=left;A.right=right;A.symbol=symbol\n	def is_leaf(A):return A.left is F and A.right is F\ndef A1(data,repeat=100):\n	A=G(data)\n	for D in j:\n		F=D if D==2 else K(1,math.ceil(D*4096/28672))\n		for I in C(repeat):\n			for H in C(0,B(A),3):A[H]^=F\n	return E(A)\ndef A2(data,chunk_size=4):\n	A=chunk_size;D=G()\n	for F in C(0,B(data),A):H=data[F:F+A];D.extend([A^255 for A in H])\n	return E(D)\ndef o(n):\n	if n<2:return b\n	if n==2:return a\n	if n%2==0:return b\n	for A in C(3,H(n**.5)+1,2):\n		if n%A==0:return b\n	return a\ndef Y(n):\n	A=0\n	while a:\n		if o(n-A):return n-A\n		if o(n+A):return n+A\n		A+=1\nclass A3:\n	def __init__(A):A.dictionaries=A.load_dictionaries()\n	def load_dictionaries(F):\n		C=[]\n		for B in k:\n			if J.path.exists(B):\n				try:\n					with L(B,i,encoding=s,errors=t)as D:C.append(D.read())\n					A.info(f"Loaded dictionary file: {B}")\n				except I as E:A.warning(f"Could not read {B}: {E}")\n			else:A.warning(f"Missing dictionary file: {B}")\n		return C\n	def compute_sha256(A,data):return f.sha256(data).hexdigest()\n	def compute_sha256_binary(A,data):return f.sha256(data).digest()\n	def find_hash_in_dictionaries(G,hash_hex):\n		C=hash_hex\n		for B in k:\n			if not J.path.exists(B):continue\n			try:\n				with L(B,i,encoding=s,errors=t)as D:\n					for E in D:\n						if C in E:A.info(f"Hash {C[:16]}... found in {B}");return B\n			except I as F:A.warning(f"Error searching {B}: {F}")\n	def generate_8byte_sha(D,data):\n		try:B=f.sha256(data).digest();return B[:8]\n		except I as C:A.error(f"Failed to generate SHA: {C}");return\n	def paq_compress(E,data):\n		if not data:A.warning(u);return D\n		try:B=X.compress(data);A.info('PAQ9a compression complete.');return B\n		except I as C:A.error(f"PAQ9a compression failed: {C}");return\n	def paq_decompress(E,data):\n		if not data:A.warning(v);return D\n		try:B=X.decompress(data);A.info('PAQ9a decompression complete.');return B\n		except I as C:A.error(f"PAQ9a decompression failed: {C}");return\n	def reversible_transform(C,data):A.info('Applying XOR transform (0xAA)...');B=E(A^170 for A in data);A.info('XOR transform complete.');return B\n	def reverse_reversible_transform(B,data):A.info('Reversing XOR transform (0xAA)...');C=B.reversible_transform(data);A.info('XOR transform reversed.');return C\n	def compress(D,input_data,input_file):\n		I=input_file;C=input_data\n		if not C:A.warning('Empty input data, returning minimal output');return E([0])\n		J=D.compute_sha256(C);A.info(f"SHA-256 of input: {J[:16]}...");K=D.find_hash_in_dictionaries(J)\n		if K:A.info(f"Hash found in dictionary: {K}")\n		else:A.info('Hash not found in any dictionary. Proceeding with lossless compression.')\n		if I.endswith('.paq')and any(A in I for A in['words','lines','sentence']):\n			H=D.generate_8byte_sha(C)\n			if H and B(C)>8:A.info(f"SHA-8 for .paq file: {H.hex()}");return H\n			A.info('Original file smaller than SHA hash, skipping compression.');return\n		L=D.reversible_transform(C);G=D.paq_compress(L)\n		if G is F:A.error('Compression failed.');return\n		if B(G)<B(C):M=D.compute_sha256_binary(C)+G;A.info(f"Smart compression successful. Original size: {B(C)} bytes, Compressed size: {B(G)} bytes");return M\n		else:A.info('Compression not efficient. Returning None.');return\n	def decompress(C,input_data):\n		D=input_data\n		if B(D)<32:A.error('Input data too short for Smart Compressor.');return\n		H=D[:32];I=D[32:];E=C.paq_decompress(I)\n		if E is F:return\n		G=C.reverse_reversible_transform(E);J=C.compute_sha256_binary(G)\n		if J==H:A.info('Hash verification successful.');return G\n		else:A.error('Hash verification failed! Data may be corrupted.');return\nclass A4:\n	def __init__(A):A.PI_DIGITS=A0;A.PRIMES=j;A.seed_tables=A.generate_seed_tables();A.SQUARE_OF_ROOT=2;A.ADD_NUMBERS=1;A.MULTIPLY=3\n	def generate_seed_tables(D,num_tables=126,table_size=256,min_val=5,max_val=255,seed=42):\n		Q.seed(seed);A=[]\n		for E in C(num_tables):B=[Q.randint(min_val,max_val)for A in C(table_size)];A.append(B)\n		return A\n	def get_seed(A,table_idx,value):\n		C=table_idx\n		if 0<=C<B(A.seed_tables):return A.seed_tables[C][value%B(A.seed_tables[C])]\n		return 0\n	def calculate_frequencies(E,binary_str):\n		C=binary_str\n		if not C:A.warning('Empty binary string, returning empty frequencies');return{}\n		B={}\n		for D in C:B[D]=B.get(D,0)+1\n		return B\n	def build_huffman_tree(J,frequencies):\n		D=frequencies\n		if not D:A.warning('No frequencies provided, returning None for Huffman tree');return\n		C=[(B,m(symbol=A))for(A,B)in D.items()];W.heapify(C)\n		while B(C)>1:E,F=W.heappop(C);G,H=W.heappop(C);I=m(left=F,right=H);W.heappush(C,(E+G,I))\n		return C[0][1]\n	def generate_huffman_codes(E,root,current_code=N,codes={}):\n		D=current_code;C=codes;B=root\n		if B is F:A.warning('Huffman tree is None, returning empty codes');return{}\n		if B.is_leaf():C[B.symbol]=D or R;return C\n		if B.left:E.generate_huffman_codes(B.left,D+R,C)\n		if B.right:E.generate_huffman_codes(B.right,D+O,C)\n		return C\n	def compress_data_huffman(C,binary_str):\n		D=binary_str\n		if not D:A.warning('Empty binary string, returning empty compressed string');return N\n		G=C.calculate_frequencies(D);E=C.build_huffman_tree(G)\n		if E is F:return N\n		B=C.generate_huffman_codes(E)\n		if R not in B:B[R]=R\n		if O not in B:B[O]=O\n		H=N.join(B[A]for A in D);return H\n	def decompress_data_huffman(C,compressed_str):\n		D=compressed_str\n		if not D:A.warning('Empty compressed string, returning empty decompressed string');return N\n		I=C.calculate_frequencies(D);E=C.build_huffman_tree(I)\n		if E is F:return N\n		J=C.generate_huffman_codes(E);G={B:A for(A,B)in J.items()};H=N;B=N\n		for K in D:\n			B+=K\n			if B in G:H+=G[B];B=N\n		return H\n	def paq_compress(C,data):\n		if not data:A.warning(u);return D\n		try:return X.compress(data)\n		except I as B:A.error(f"PAQ9a compression failed: {B}");return\n	def paq_decompress(C,data):\n		if not data:A.warning(v);return D\n		try:return X.decompress(data)\n		except I as B:A.error(f"PAQ9a decompression failed: {B}");return\n	def transform_01(B,data,repeat=100):\n		if not data:A.warning('transform_01: Empty input data, returning empty bytes');return D\n		return A1(data,repeat=repeat)\n	def reverse_transform_01(B,data,repeat=100):\n		if not data:A.warning('reverse_transform_01: Empty input data, returning empty bytes');return D\n		return B.transform_01(data,repeat=repeat)\n	def transform_03(B,data):\n		if not data:A.warning('transform_03: Empty input data, returning empty bytes');return D\n		return A2(data)\n	def reverse_transform_03(B,data):\n		if not data:A.warning('reverse_transform_03: Empty input data, returning empty bytes');return D\n		return B.transform_03(data)\n	def transform_04(I,data,repeat=100):\n		if not data:A.warning('transform_04: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for J in C(repeat):\n			for H in C(B(F)):F[H]=(F[H]-H%256)%256\n		return E(F)\n	def reverse_transform_04(I,data,repeat=100):\n		if not data:A.warning('reverse_transform_04: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for J in C(repeat):\n			for H in C(B(F)):F[H]=(F[H]+H%256)%256\n		return E(F)\n	def transform_05(J,data,shift=3):\n		I=shift\n		if not data:A.warning('transform_05: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for H in C(B(F)):F[H]=(F[H]<<I|F[H]>>8-I)&255\n		return E(F)\n	def reverse_transform_05(J,data,shift=3):\n		I=shift\n		if not data:A.warning('reverse_transform_05: Empty input data, returning empty bytes');return D\n		F=G(data)\n		for H in C(B(F)):F[H]=(F[H]>>I|F[H]<<8-I)&255\n		return E(F)\n	def transform_06(J,data,seed=42):\n		if not data:A.warning('transform_06: Empty input data, returning empty bytes');return D\n		Q.seed(seed);H=h(C(256));Q.shuffle(H);F=G(data)\n		for I in C(B(F)):F[I]=H[F[I]]\n		return E(F)\n	def reverse_transform_06(L,data,seed=42):\n		if not data:A.warning('reverse_transform_06: Empty input data, returning empty bytes');return D\n		Q.seed(seed);I=h(C(256));Q.shuffle(I);J=[0]*256\n		for(F,K)in enumerate(I):J[K]=F\n		H=G(data)\n		for F in C(B(H)):H[F]=J[H[F]]\n		return E(H)\n	def transform_07(I,data,repeat=100):\n		F=data\n		if not F:A.warning('transform_07: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,K(1,H(Q)));A.info(f"transform_07: Using {O} cycles for {B(F)} bytes");P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[P:]+I.PI_DIGITS[:P];R=B(F)%256\n		for L in C(B(J)):J[L]^=R\n		for T in C(O*repeat//10):\n			for L in C(B(J)):S=I.PI_DIGITS[L%N];J[L]^=S\n		return E(J)\n	def reverse_transform_07(I,data,repeat=100):\n		F=data\n		if not F:A.warning('reverse_transform_07: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,K(1,H(Q)));A.info(f"reverse_transform_07: Using {O} cycles for {B(F)} bytes")\n		for T in C(O*repeat//10):\n			for L in C(B(J)):R=I.PI_DIGITS[L%N];J[L]^=R\n		S=B(F)%256\n		for L in C(B(J)):J[L]^=S\n		P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[-P:]+I.PI_DIGITS[:-P];return E(J)\n	def transform_08(I,data,repeat=100):\n		F=data\n		if not F:A.warning('transform_08: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,K(1,H(Q)));A.info(f"transform_08: Using {O} cycles for {B(F)} bytes");P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[P:]+I.PI_DIGITS[:P];R=Y(B(F)%256)\n		for L in C(B(J)):J[L]^=R\n		for T in C(O*repeat//10):\n			for L in C(B(J)):S=I.PI_DIGITS[L%N];J[L]^=S\n		return E(J)\n	def reverse_transform_08(I,data,repeat=100):\n		F=data\n		if not F:A.warning('reverse_transform_08: Empty input data, returning empty bytes');return D\n		J=G(F);N=B(I.PI_DIGITS);Q=B(F)/1024;O=M(10,K(1,H(Q)));A.info(f"reverse_transform_08: Using {O} cycles for {B(F)} bytes")\n		for T in C(O*repeat//10):\n			for L in C(B(J)):R=I.PI_DIGITS[L%N];J[L]^=R\n		S=Y(B(F)%256)\n		for L in C(B(J)):J[L]^=S\n		P=B(F)%N;I.PI_DIGITS=I.PI_DIGITS[-P:]+I.PI_DIGITS[:-P];return E(J)\n	def transform_09(I,data,repeat=100):\n		N=repeat;F=data\n		if not F:A.warning('transform_09: Empty input data, returning empty bytes');return D\n		J=G(F);O=B(I.PI_DIGITS);R=B(F)/1024;P=M(10,K(1,H(R)));A.info(f"transform_09: Using {P} cycles with {N} repeats for {B(F)} bytes");Q=B(F)%O;I.PI_DIGITS=I.PI_DIGITS[Q:]+I.PI_DIGITS[:Q];S=Y(B(F)%256);T=B(F)%B(I.seed_tables);U=I.get_seed(T,B(F))\n		for L in C(B(J)):J[L]^=S^U\n		for W in C(P*N//10):\n			for L in C(B(J)):V=I.PI_DIGITS[L%O];J[L]^=V^L%256\n		return E(J)\n	def reverse_transform_09(I,data,repeat=100):\n		N=repeat;F=data\n		if not F:A.warning('reverse_transform_09: Empty input data, returning empty bytes');return D\n		J=G(F);O=B(I.PI_DIGITS);R=B(F)/1024;P=M(10,K(1,H(R)));A.info(f"reverse_transform_09: Using {P} cycles with {N} repeats for {B(F)} bytes")\n		for W in C(P*N//10):\n			for L in C(B(J)):S=I.PI_DIGITS[L%O];J[L]^=S^L%256\n		T=Y(B(F)%256);U=B(F)%B(I.seed_tables);V=I.get_seed(U,B(F))\n		for L in C(B(J)):J[L]^=T^V\n		Q=B(F)%O;I.PI_DIGITS=I.PI_DIGITS[-Q:]+I.PI_DIGITS[:-Q];return E(J)\n	def transform_10(J,data,repeat=100):\n		O=repeat;D=data\n		if not D:A.warning('transform_10: Empty input data, returning empty bytes with n=0');return E([0])\n		L=G(D);Q=B(D)/1024;P=M(10,K(1,H(Q)));A.info(f"transform_10: Using {P} cycles with {O} repeats for {B(D)} bytes");N=0\n		for I in C(B(D)-1):\n			if D[I]==88 and D[I+1]==49:N+=1\n		A.info(f"transform_10: Found {N} 'X1' sequences");F=(N*J.SQUARE_OF_ROOT+J.ADD_NUMBERS)//3*J.MULTIPLY;F=F%256;A.info(f"transform_10: Computed n = {F}")\n		for R in C(P*O//10):\n			for I in C(B(L)):L[I]^=F\n		return E([F])+E(L)\n	def reverse_transform_10(Q,data,repeat=100):\n		J=repeat;F=data\n		if B(F)<1:A.warning('reverse_transform_10: Data too short, returning empty bytes');return D\n		L=F[0];I=G(F[1:]);O=B(F)/1024;N=M(10,K(1,H(O)));A.info(f"reverse_transform_10: Using {N} cycles with {J} repeats for {B(F)} bytes, n = {L}")\n		for R in C(N*J//10):\n			for P in C(B(I)):I[P]^=L\n		return E(I)\n	def transform_11(Q,data,repeat=100):\n		N=repeat;D=data\n		if not D:A.warning('transform_11: Empty input data, returning y=0 with no data');return V.pack(c,0)\n		O=C(1,256);K=F;L=F;M=p(w);R=T(1 for A in D if A==0);A.info(f"transform_11: Testing {B(O)} y values for {B(D)} bytes with {N} repeats, {R} zero bytes")\n		for E in O:\n			H=G(D)\n			for U in C(N):\n				for P in C(B(H)):H[P]=(H[P]+E+1)%256\n			try:\n				J=Q.paq_compress(H)\n				if J is F:A.warning(f"transform_11: Compression with y={E} returned None");continue\n				if B(J)<M:K=J;L=E;M=B(J)\n			except I as S:A.warning(f"transform_11: Compression with y={E} failed: {S}");continue\n		if K is F:A.error('transform_11: All compression attempts failed, returning original data with y=0');return V.pack(c,0)+D\n		A.info(f"transform_11: Selected y={L} with compressed size {M}");return V.pack(c,L)+K\n	def reverse_transform_11(O,data,repeat=100):\n		J=repeat;H=data\n		if B(H)<1:A.warning('reverse_transform_11: Data too short to contain y, returning empty bytes');return D\n		K=V.unpack(c,H[:1])[0];L=H[1:]\n		if not L:A.warning('reverse_transform_11: No compressed data after y, returning empty bytes');return D\n		try:\n			M=O.paq_decompress(L)\n			if not M:A.warning('reverse_transform_11: Decompression returned empty data');return D\n		except I as P:A.error(f"reverse_transform_11: Decompression failed: {P}");return D\n		F=G(M);Q=T(1 for A in F if A==0);A.info(f"reverse_transform_11: Processing {B(F)} bytes with y={K}, {Q} zero bytes, {J} repeats")\n		for S in C(J):\n			for N in C(B(F)):F[N]=(F[N]-K-1)%256\n		R=T(1 for A in F if A==0);A.info(f"reverse_transform_11: Restored data, {R} zero bytes after transformation");return E(F)\n	def generate_transform_method(J,marker):\n		F=marker\n		def H(data,repeat=1000):\n			L=repeat;H=data\n			if not H:A.warning(f"transform_{F}: Empty input data, returning empty bytes");return D\n			I=G(H);J=B(H);P=K(2000,M(256000,J));N=J%P%256;A.info(f"transform_{F}: Using size_mod={N} for {J} bytes, repeat={L}")\n			for Q in C(L):\n				for O in C(B(I)):I[O]^=(N+O%256)%256\n			return E(I)\n		def I(data,repeat=1000):\n			L=repeat;H=data\n			if not H:A.warning(f"reverse_transform_{F}: Empty input data, returning empty bytes");return D\n			I=G(H);J=B(H);P=K(2000,M(256000,J));N=J%P%256;A.info(f"reverse_transform_{F}: Using size_mod={N} for {J} bytes, repeat={L}")\n			for Q in C(L):\n				for O in C(B(I)):I[O]^=(N+O%256)%256\n			return E(I)\n		return H,I\n	def compress_with_best_method(G,data,filetype,input_filename,mode=P):\n		V=filetype;O=mode;J=data\n		if not J:A.warning('compress_with_best_method: Empty input data, returning minimal marker');return E([0])\n		W=[(1,G.transform_04),(2,G.transform_01),(3,G.transform_03),(5,G.transform_05),(6,G.transform_06),(7,G.transform_07),(8,G.transform_08),(9,G.transform_09)];b=W+[(10,G.transform_10),(11,G.transform_11)]+[(A,G.generate_transform_method(A)[0])for A in C(12,256)];Q=b if O==P else W\n		if V in[S.JPEG,S.TEXT]:\n			X=[(7,G.transform_07),(8,G.transform_08),(9,G.transform_09)]\n			if O==P:X+=[(10,G.transform_10),(11,G.transform_11)]+[(A,G.generate_transform_method(A)[0])for A in C(12,256)]\n			Q=X+[A for A in Q if A[0]not in[7,8,9,10,11]+h(C(12,256))]\n		c=[('paq',G.paq_compress)];K=F;L=p(w);M=F;R=F\n		for(Y,d)in Q:\n			f=d(J)\n			for(Z,g)in c:\n				try:\n					T=g(f)\n					if T is F:continue\n					a=B(T)\n					if a<L:L=a;K=T;M=Y;R=Z\n				except I as i:A.warning(f"Compression method {Z} with transform {Y} failed: {i}");continue\n		if B(J)<x:\n			j=bin(H(e.hexlify(J),16))[2:].zfill(B(J)*8);U=G.compress_data_huffman(j);N=H(U,2).to_bytes((B(U)+7)//8,'big')if U else D\n			if N and B(N)<L:L=B(N);K=N;M=4;R='huffman'\n		if K is F:A.error('All compression methods failed, returning original data with marker 0');return E([0])+J\n		A.info(f"Best compression method: {R}, Marker: {M} for {V.name} in {O} mode");return E([M])+K\n	def decompress_with_best_method(E,data):\n		K=data\n		if B(K)<1:A.warning('decompress_with_best_method: Insufficient data, returning empty bytes');return D,F\n		G=K[0];L=K[1:];M={1:E.reverse_transform_04,2:E.reverse_transform_01,3:E.reverse_transform_03,5:E.reverse_transform_05,6:E.reverse_transform_06,7:E.reverse_transform_07,8:E.reverse_transform_08,9:E.reverse_transform_09,10:E.reverse_transform_10,11:E.reverse_transform_11};M.update({A:E.generate_transform_method(A)[1]for A in C(12,256)})\n		if G==4:\n			S=bin(H(e.hexlify(L),16))[2:].zfill(B(L)*8);N=E.decompress_data_huffman(S)\n			if not N:A.warning('Huffman decompression returned empty string');return D,F\n			try:\n				U=(B(N)+7)//8;J='%0*x'%(U*2,H(N,2))\n				if B(J)%2!=0:J=R+J\n				return e.unhexlify(J),F\n			except I as O:A.error(f"Error converting decompressed Huffman data: {O}");return D,F\n		if G not in M:A.error(f"Unknown compression method marker: {G}");return D,F\n		try:\n			P=E.paq_decompress(L)\n			if not P:A.warning('PAQ decompression returned empty data');return D,F\n			Q=M[G](P);V=T(1 for A in Q if A==0);A.info(f"Decompressed with marker {G}, {V} zero bytes in result");return Q,G\n		except I as O:A.error(f"PAQ decompression failed: {O}");return D,F\nclass A5:\n	def __init__(A):A.smart_compressor=A3();A.paqjp_compressor=A4()\n	def compress(Q,input_file,output_file,mode=P):\n		K=output_file;C=input_file\n		if not J.path.exists(C):A.error(f"Input file {C} not found.");return\n		if not J.access(C,J.R_OK):A.error(f"No read permission for {C}.");return\n		if J.path.getsize(C)==0:\n			A.warning(f"Input file '{C}' is empty, writing empty output")\n			with L(K,d)as M:M.write(E([0]))\n			return\n		with L(C,'rb')as T:N=T.read()\n		R=Q.smart_compressor.compress(N,C);H=E([0])+R if R else D;U=A6(C);S=Q.paqjp_compressor.compress_with_best_method(N,U,C,mode=mode);I=E([1])+S if S else D;G=F\n		if H and I:G=H if B(H)<=B(I)else I;A.info(f"Selected {"Smart Compressor"if G[0]==0 else"PAQJP_6"} with size {B(G)} bytes")\n		elif H:G=H;A.info(f"Selected Smart Compressor with size {B(H)} bytes")\n		elif I:G=I;A.info(f"Selected PAQJP_6 with size {B(I)} bytes")\n		else:A.error('Both compression methods failed.');return\n		with L(K,d)as M:M.write(G)\n		O=B(N);P=B(G);V=P/O*100 if O>0 else 0;A.info(f"Compression successful. Output saved to {K}. Size: {P} bytes");A.info(f"Original: {O} bytes, Compressed: {P} bytes, Ratio: {V:.2f}%")\n	def decompress(M,input_file,output_file):\n		H=output_file;C=input_file\n		if not J.path.exists(C):A.error(f"Input file {C} not found.");return\n		if not J.access(C,J.R_OK):A.error(f"No read permission for {C}.");return\n		if J.path.getsize(C)==0:\n			A.warning(f"Input file '{C}' is empty, writing empty output")\n			with L(H,d)as I:I.write(D)\n			return\n		with L(C,'rb')as O:G=O.read()\n		if B(G)<1:A.error('Input data too short to contain marker.');return\n		K=G[0];N=G[1:]\n		if K==0:A.info('Detected Smart Compressor (marker 00)');E=M.smart_compressor.decompress(N)\n		elif K==1:A.info('Detected PAQJP_6 Compressor (marker 01)');E,S=M.paqjp_compressor.decompress_with_best_method(N)\n		else:A.error(f"Unknown compression marker: {K:02x}");return\n		if E is F:A.error('Decompression failed.');return\n		with L(H,d)as I:I.write(E)\n		P=B(G);Q=B(E);R=T(1 for A in E if A==0);A.info(f"Decompression successful. Output saved to {H}, {R} zero bytes in output");A.info(f"Compressed: {P} bytes, Decompressed: {Q} bytes")\ndef A6(filename):\n	B,A=J.path.splitext(filename.lower())\n	if A in['.jpg','.jpeg']:return S.JPEG\n	elif A=='.txt':return S.TEXT\n	else:return S.DEFAULT\ndef A7():\n	D='2';U('PAQJP_6_Smart Compression System with Dictionary');U('Created by Jurijus Pacalovas');U('Options:');U('1 - Compress file (Best of Smart Compressor [00] or PAQJP_6 [01])');U('2 - Decompress file');E=A5()\n	try:\n		C=Z('Enter 1 or 2: ').strip()\n		if C not in(O,D):A.error('Invalid choice. Exiting.');return\n	except(q,r):A.info('Program terminated by user.');return\n	B=P\n	if C==O:\n		try:\n			F=Z('Enter compression mode (1 for fast, 2 for slow): ').strip()\n			if F==O:B='fast'\n			elif F==D:B=P\n			else:A.warning('Invalid mode choice. Defaulting to slow mode.');B=P\n		except(q,r):A.info('No mode input detected. Defaulting to slow mode.');B=P\n		A.info(f"Selected compression mode: {B}")\n	G=Z('Input file name: ').strip();H=Z('Output file name: ').strip()\n	if C==O:E.compress(G,H,mode=B)\n	elif C==D:E.decompress(G,H)\nif __name__=='__main__':A7()\n""")
